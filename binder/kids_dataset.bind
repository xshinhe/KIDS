py::class_<DataSet> PyDataSet(m, "DataSet", py::dynamic_attr());

PyDataSet.def(py::init<>())
    .def("def_int32", &DataSet::_def<int>, py::arg("key") = "0", py::arg("size") = 1)
    .def("def_float64", &DataSet::_def<double>, py::arg("key") = "0", py::arg("size") = 1)
    .def("def_complex128", &DataSet::_def<std::complex<double>>, py::arg("key") = "0", py::arg("size") = 1)
    .def("undef", &DataSet::_undef, py::arg("key") = "0");
    
PyDataSet.def("numpy", [](DataSet& self, const std::string& key) {
    auto inode = self.node(key);
    kids_dtype n_type = inode->type();
    std::size_t n_size = inode->size();
    void* n_data = inode->data();
    switch (n_type) {
        case kids_int_type: {
            return py::array({n_size},                                          // shape
                             {sizeof(int)},                                     // stride
                             (int*) n_data,                                     // data pointer
                             py::capsule(n_data, [](void* _void_n_data) { ; })  // zero-copy cost
            );
            break;
        }
        case kids_real_type: {
            return py::array({n_size},                                          // shape
                             {sizeof(kids_real)},                                // stride
                             (kids_real*) n_data,                                // data pointer
                             py::capsule(n_data, [](void* _void_n_data) { ; })  // zero-copy cost
            );
            break;
        }
        case kids_complex_type: {
            return py::array({n_size},                                          // shape
                             {sizeof(kids_complex)},                             // stride
                             (kids_complex*) n_data,                             // data pointer
                             py::capsule(n_data, [](void* _void_n_data) { ; })  // zero-copy cost
            );
            break;
        }
        default:
            throw std::runtime_error("can not converted to numpy!");
    }
    return py::array();
});

PyDataSet.def("__repr__", [](DataSet& self) { return self.repr(); });
