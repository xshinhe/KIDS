#include "Model_SystemBath.h"

// #include <glog/logging.h>

#include "../core/linalg.h"
#include "../kernels/Kernel_Random.h"
#include "hamiltonian_data.h"

namespace PROJECT_NS {

void Bath::read_param_impl(Param* PM) {
    _Param = PM;
    // size information
    Nb    = _Param->get<int>("Nb", LOC());
    nbath = _Param->get<int>("nbath", LOC());

    //// CHECK_EQ(Nb * nbath, N);  // Nb*nbath must be N

    bath_type   = BathPolicy::_from(_Param->get<std::string>("bath_flag", LOC(), "debye"));
    omegac      = _Param->get<double>("omegac", LOC(), phys::energy_d, 1.0f);
    lambda_type = LambdaPolicy::_from(_Param->get<std::string>("lambda_flag", LOC(), "lambda"));
    switch (lambda_type) {
        case LambdaPolicy::Lambda: {
            double strength = _Param->get<double>("strength", LOC(), phys::energy_d, 1.0f);
            lambda          = strength;
            break;
        }
        case LambdaPolicy::Alpha: {
            double strength = _Param->get<double>("strength", LOC(), 1.0f);
            lambda          = 0.5f * omegac * strength;
            break;
        }
        case LambdaPolicy::Eta: {
            double strength = _Param->get<double>("strength", LOC(), phys::energy_d, 1.0f);
            lambda          = 0.5f * strength;
            break;
        }
        case LambdaPolicy::Erg: {
            double strength = _Param->get<double>("strength", LOC(), phys::energy_d, 1.0f);
            lambda          = 0.25f * strength;
            break;
        }
    }
    double temperature = _Param->get<double>("temperature", LOC(), phys::temperature_d, 1.0f);
    bath.beta          = 1.0f / (phys::au::k * temperature);  // don't ignore k_Boltzman
}


void Model_SystemBath::read_param_impl(Param* PM) {
    _Param = PM;

    // size information
    F     = _Param->get<int>("F", LOC());
    N     = _Param->get<int>("N", LOC());
    Nb    = _Param->get<int>("Nb", LOC());
    nbath = _Param->get<int>("nbath", LOC());

    //// CHECK_EQ(Nb * nbath, N);  // Nb*nbath must be N

    system_type   = SystemPolicy::_from(_Param->get<std::string>("system_flag", LOC(), "sb"));
    bath_type     = BathPolicy::_from(_Param->get<std::string>("bath_flag", LOC(), "debye"));
    coupling_type = CouplingPolicy::_from(_Param->get<std::string>("coupling_flag", LOC(), "se"));

    bath.bath_type   = bath_type;
    bath.omegac      = _Param->get<double>("omegac", LOC(), phys::energy_d, 1.0f);
    bath.lambda_type = LambdaPolicy::_from(_Param->get<std::string>("lambda_flag", LOC(), "lambda"));
    switch (bath.lambda_type) {
        case LambdaPolicy::Lambda: {
            double strength = _Param->get<double>("strength", LOC(), phys::energy_d, 1.0f);
            bath.lambda     = strength;
            break;
        }
        case LambdaPolicy::Alpha: {
            double strength = _Param->get<double>("strength", LOC(), 1.0f);
            bath.lambda     = 0.5f * bath.omegac * strength;
            break;
        }
        case LambdaPolicy::Eta: {
            double strength = _Param->get<double>("strength", LOC(), phys::energy_d, 1.0f);
            bath.lambda     = 0.5f * strength;
            break;
        }
        case LambdaPolicy::Erg: {
            double strength = _Param->get<double>("strength", LOC(), phys::energy_d, 1.0f);
            bath.lambda     = 0.25f * strength;
            break;
        }
    }
    double temperature = _Param->get<double>("temperature", LOC(), phys::temperature_d, 1.0f);
    bath.beta          = 1.0f / (phys::au::k * temperature);  // don't ignore k_Boltzman
}


void Bath::init_data_impl(DataSet* DS) {
    /// 1) System
    Hsys = DS->reg<num_real>("model.Hsys", F * F);
    L    = 1;
    switch (system_type) {
        case SystemPolicy::SB: {
            //// CHECK_EQ(F, 2);
            L             = 2;
            double bias   = _Param->get<double>("bias", LOC(), phys::energy_d, 1.0f);
            double delta  = _Param->get<double>("delta", LOC(), phys::energy_d, 1.0f);
            double HSB[4] = {bias, delta, delta, -bias};
            for (int i = 0; i < FF; ++i) Hsys[i] = HSB[i];
            break;
        }
        case SystemPolicy::FMO: {
            //// CHECK_EQ(nbath, 7);
            //// CHECK_GE(F, 7);  // F = 7, or F = 8 (include ground state in the last; be careful)
            double tmp_unit = phys::au_2_wn;
            memset(Hsys, 0, FF * sizeof(num_real));
            for (int i = 0, ik = 0; i < 7; ++i) {
                for (int k = 0; k < 7; ++k, ++ik) { Hsys[i * F + k] = HFMO_data[ik] / tmp_unit; }
            }
            break;
        }
        case SystemPolicy::SF3a: {
            //// CHECK_EQ(F, 3);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF3a_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::SF3b: {
            //// CHECK_EQ(F, 3);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF3b_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::SF5a: {
            //// CHECK_EQ(F, 5);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF5a_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::SF5b: {
            //// CHECK_EQ(F, 5);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF5b_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::FCP: {
            //// CHECK_EQ(nbath, 9);
            //// CHECK_GE(F, 9);  // F = 9, or F = 10 (include ground state; be careful)
            double tmp_unit = phys::au_2_wn;
            memset(Hsys, 0, FF * sizeof(num_real));
            for (int i = 0, ik = 0; i < 9; ++i) {
                for (int k = 0; k < 9; ++k, ++ik) { Hsys[i * F + k] = HFCP_data[ik] / tmp_unit; }
            }
            break;
        }
        case SystemPolicy::AGG: {
            //// CHECK_GE(F, 2);
            double delta = _Param->get<double>("delta", LOC(), phys::energy_d, 1.0f);
            for (int i = 0, ik = 0; i < F; ++i) {
                for (int k = 0; k < F; ++k, ++ik) Hsys[ik] = (i - k == 1 || k - i == 1) ? delta : 0.0f;
            }
            break;
        }
        case SystemPolicy::CYC: {
            //// CHECK_GE(F, 2);
            double delta = _Param->get<double>("delta", LOC(), phys::energy_d, 1.0f);
            for (int i = 0, ik = 0; i < F; ++i) {
                for (int k = 0; k < F; ++k, ++ik) Hsys[ik] = (i - k == 1 || k - i == 1) ? delta : 0.0f;
            }
            Hsys[0 * F + (F - 1)] = delta;
            Hsys[(F - 1) * F + 0] = delta;
            break;
        }
        case SystemPolicy::Read: {
            std::string system_readfile = _Param->get<std::string>("system_readfile", LOC(), "system.dat");
            std::ifstream ifs(system_readfile);
            std::string H_unit_str;
            std::string firstline;
            getline(ifs, firstline);
            std::stringstream sstr(firstline);
            sstr >> H_unit_str;  ///< the firstline stores H's unit

            double H_unit = phys::us::conv(phys::au::unit, phys::us::parse(H_unit_str));
            num_real val;
            for (int i = 0; i < FF; ++i)
                if (ifs >> val) Hsys[i] = val / H_unit;
            ifs.close();
        }
    }

    /// 2) Bath (init omegas, coeffs; m, w, x_sigma, p_sigma)
    omegas = DS->reg<double>("model.omegas", Nb);
    coeffs = DS->reg<double>("model.coeffs", Nb);
    switch (bath_type) {
        case BathPolicy::Debye: {  // from continuous spectrum
            for (int j = 0; j < Nb; ++j) {
                omegas[j] = bath.omegac * std::tan(phys::math::halfpi * ((j + 1.0f) / (Nb + 1.0f)));
                coeffs[j] = sqrt(2 * bath.lambda / (Nb + 1.0f)) * omegas[j];
            }
            break;
        }
        case BathPolicy::Ohmic: {  // from continuous spectrum
            for (int j = 0; j < Nb; ++j) {
                omegas[j] = -bath.omegac * std::log(1.0f - (j + 1.0f) / (Nb + 1.0f));
                coeffs[j] = sqrt(2 * bath.lambda / (Nb + 1.0f)) * omegas[j];
            }
            break;
        }
        case BathPolicy::Closure: {  // from continuous spectrum
            break;
        }
        case BathPolicy::ReadFormula: {  // from continuous spectrum
            break;
        }
        case BathPolicy::ReadFile:  // #b850, #pbi, #rub
        default: {
            try {
                std::string bath_readfile = _Param->get<std::string>("bath_readfile", LOC(), "bath.spectrum");
                std::ifstream ifs(bath_readfile);

                std::string firstline, unit_str1, unit_str2, DIS_FLAG;

                // parse units of frequency & coefficients
                getline(ifs, firstline);
                std::stringstream sstr(firstline);
                sstr >> unit_str1 >> unit_str2;

                phys::uval uw = phys::us::parse(unit_str1);
                // if (uw.dim != phys::energy_d) LOG(FATAL) << "need dimension of energy";
                double w_unit = phys::us::conv(phys::au::unit, uw);

                phys::uval uc = phys::us::parse(unit_str2);
                // if (uc.dim != phys::energy_d) LOG(FATAL) << "need dimension of energy";
                double c_unit = phys::us::conv(phys::au::unit, uc);

                // read data lines
                double val;
                for (int j = 0; j < Nb; ++j) {
                    ifs >> DIS_FLAG;
                    if (DIS_FLAG == "WC") {
                        if (ifs >> val) omegas[j] = val / w_unit;              ///< omegac ~ [energy_d]
                        if (ifs >> val) coeffs[j] = val / pow(c_unit, 1.5e0);  ///< coeffs ~ [energy_d]**1.5
                    } else if (DIS_FLAG == "WS") {
                        if (ifs >> val) omegas[j] = val / w_unit;
                        if (ifs >> val) coeffs[j] = 2.0f * sqrt(0.5f * omegas[j] * omegas[j] * omegas[j] * val);
                    } else if (DIS_FLAG == "WG") {
                        if (ifs >> val) omegas[j] = val / w_unit;  ///< omegac ~ [energy_d]
                        if (ifs >> val) coeffs[j] = 2.0f * sqrt(0.5f * omegas[j] * omegas[j] * omegas[j]) * val;
                    }
                }
            } catch (std::runtime_error& e) {
                // LOG(FATAL) << "read spec.dat error";
            }
        }
    }
    mass    = DS->reg<double>("model.mass", N);
    freq    = DS->reg<double>("model.freq", N);
    x_mean  = DS->reg<double>("model.x_mean", N);
    p_mean  = DS->reg<double>("model.p_mean", N);
    x_sigma = DS->reg<double>("model.x_sigma", N);
    p_sigma = DS->reg<double>("model.p_sigma", N);
    for (int j = 0; j < N; ++j) {
        mass[j] = 1.0f;
        freq[j] = omegas[j % Nb];
        /* note:
            for finite temperature: Qoverbeta = 0.5*freq / dtanh(0.5*beta*freq)
            for zero temperature:   Qoverbeta = 0.5*freq
         */
        double Qoverbeta = 0.5f * freq[j] / (bath.beta > 0 ? std::tanh(0.5f * bath.beta * freq[j]) : 1.0f);
        x_sigma[j]       = std::sqrt(Qoverbeta / (mass[j] * freq[j] * freq[j]));
        p_sigma[j]       = std::sqrt(Qoverbeta * mass[j]);
    }


    /// 3) Coupling (saving order: L, nbath, Nb, FF)
    Q   = DS->reg<double>("model.Q", nbath * F * F);
    CL  = DS->reg<double>("model.CL", L * Nb);
    QL  = DS->reg<double>("model.QL", L * nbath * F * F);
    Xnj = DS->reg<double>("model.Xnj", N * F * F);
    switch (coupling_type) {
        case CouplingPolicy::SB: {
            //// CHECK_EQ(nbath, 1);
            //// CHECK_EQ(F, 2);
            Q[0] = 1.0f, Q[1] = 0.0f, Q[2] = 0.0f, Q[3] = -1.0f;
            break;
        }
        case CouplingPolicy::SE: {
            //// CHECK_LE(nbath, F);  // nbath should equal or less than F. (a ground state can be placed in last)
            for (int i = 0, idx = 0; i < nbath; ++i) {
                for (int j = 0; j < F; ++j) {
                    for (int k = 0; k < F; ++k, ++idx) Q[idx] = (i == j && i == k) ? 1.0f : 0.0f;
                }
            }
            break;
        }
        default: {
            std::string coupling_readfile = _Param->get<std::string>("coupling_readfile", LOC(), "coupling.dat");
            std::ifstream ifs(coupling_readfile);
            num_real tmp;
            for (int i = 0; i < nbath * F * F; ++i)
                if (ifs >> tmp) Q[i] = tmp;
            ifs.close();
        }
    }
    ARRAY_CLEAR(QL, L * nbath * FF);
    for (int ibath = 0, idx = 0; ibath < nbath; ++ibath) {
        for (int j = 0; j < Nb; ++j) {
            for (int i = 0, iL = 0; i < FF; ++i, ++idx) {
                double Qval = Q[ibath * FF + i];
                if (Qval != 0) {
                    QL[iL * nbath * FF + ibath * FF + i] = 1;                 // record there is a nonzero value
                    CL[iL * Nb + j]                      = coeffs[j] * Qval;  // reduce this value to CL
                    iL++;
                    // if (iL > L) LOG(FATAL);  // Q shoule be sparsed!
                }
                Xnj[idx] = coeffs[j] * Q[ibath * FF + i];  // merge coeffs into Q to obtain Xnj
            }
        }
    }

    // model field
    vpes = DS->reg<double>("model.vpes");
    grad = DS->reg<double>("model.grad", N);
    hess = DS->reg<double>("model.hess", N);
    V    = DS->reg<double>("model.V", FF);
    dV   = DS->reg<double>("model.dV", NFF);
    ddV  = DS->reg<double>("model.ddV", NNFF);

    // init & integrator
    x_init = DS->reg<double>("init.x", N);
    p_init = DS->reg<double>("init.p", N);
    x      = DS->reg<double>("integrator.x", N);
    p      = DS->reg<double>("integrator.p", N);
}

void Model_SystemBath::init_data_impl(DataSet* DS) {
    /// 1) System
    Hsys = DS->reg<num_real>("model.Hsys", F * F);
    L    = 1;
    switch (system_type) {
        case SystemPolicy::SB: {
            //// CHECK_EQ(F, 2);
            L             = 2;
            double bias   = _Param->get<double>("bias", LOC(), phys::energy_d, 1.0f);
            double delta  = _Param->get<double>("delta", LOC(), phys::energy_d, 1.0f);
            double HSB[4] = {bias, delta, delta, -bias};
            for (int i = 0; i < FF; ++i) Hsys[i] = HSB[i];
            break;
        }
        case SystemPolicy::FMO: {
            //// CHECK_EQ(nbath, 7);
            //// CHECK_GE(F, 7);  // F = 7, or F = 8 (include ground state in the last; be careful)
            double tmp_unit = phys::au_2_wn;
            memset(Hsys, 0, FF * sizeof(num_real));
            for (int i = 0, ik = 0; i < 7; ++i) {
                for (int k = 0; k < 7; ++k, ++ik) { Hsys[i * F + k] = HFMO_data[ik] / tmp_unit; }
            }
            break;
        }
        case SystemPolicy::SF3a: {
            //// CHECK_EQ(F, 3);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF3a_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::SF3b: {
            //// CHECK_EQ(F, 3);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF3b_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::SF5a: {
            //// CHECK_EQ(F, 5);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF5a_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::SF5b: {
            //// CHECK_EQ(F, 5);
            double tmp_unit = phys::au_2_ev;
            for (int i = 0; i < FF; ++i) Hsys[i] = HSF5b_data[i] / tmp_unit;
            break;
        }
        case SystemPolicy::FCP: {
            //// CHECK_EQ(nbath, 9);
            //// CHECK_GE(F, 9);  // F = 9, or F = 10 (include ground state; be careful)
            double tmp_unit = phys::au_2_wn;
            memset(Hsys, 0, FF * sizeof(num_real));
            for (int i = 0, ik = 0; i < 9; ++i) {
                for (int k = 0; k < 9; ++k, ++ik) { Hsys[i * F + k] = HFCP_data[ik] / tmp_unit; }
            }
            break;
        }
        case SystemPolicy::AGG: {
            //// CHECK_GE(F, 2);
            double delta = _Param->get<double>("delta", LOC(), phys::energy_d, 1.0f);
            for (int i = 0, ik = 0; i < F; ++i) {
                for (int k = 0; k < F; ++k, ++ik) Hsys[ik] = (i - k == 1 || k - i == 1) ? delta : 0.0f;
            }
            break;
        }
        case SystemPolicy::CYC: {
            //// CHECK_GE(F, 2);
            double delta = _Param->get<double>("delta", LOC(), phys::energy_d, 1.0f);
            for (int i = 0, ik = 0; i < F; ++i) {
                for (int k = 0; k < F; ++k, ++ik) Hsys[ik] = (i - k == 1 || k - i == 1) ? delta : 0.0f;
            }
            Hsys[0 * F + (F - 1)] = delta;
            Hsys[(F - 1) * F + 0] = delta;
            break;
        }
        case SystemPolicy::Read: {
            std::string system_readfile = _Param->get<std::string>("system_readfile", LOC(), "system.dat");
            std::ifstream ifs(system_readfile);
            std::string H_unit_str;
            std::string firstline;
            getline(ifs, firstline);
            std::stringstream sstr(firstline);
            sstr >> H_unit_str;  ///< the firstline stores H's unit

            double H_unit = phys::us::conv(phys::au::unit, phys::us::parse(H_unit_str));
            num_real val;
            for (int i = 0; i < FF; ++i)
                if (ifs >> val) Hsys[i] = val / H_unit;
            ifs.close();
        }
    }

    /// 2) Bath (init omegas, coeffs; m, w, x_sigma, p_sigma)
    omegas = DS->reg<double>("model.omegas", Nb);
    coeffs = DS->reg<double>("model.coeffs", Nb);
    switch (bath_type) {
        case BathPolicy::Debye: {  // from continuous spectrum
            for (int j = 0; j < Nb; ++j) {
                omegas[j] = bath.omegac * std::tan(phys::math::halfpi * ((j + 1.0f) / (Nb + 1.0f)));
                coeffs[j] = sqrt(2 * bath.lambda / (Nb + 1.0f)) * omegas[j];
            }
            break;
        }
        case BathPolicy::Ohmic: {  // from continuous spectrum
            for (int j = 0; j < Nb; ++j) {
                omegas[j] = -bath.omegac * std::log(1.0f - (j + 1.0f) / (Nb + 1.0f));
                coeffs[j] = sqrt(2 * bath.lambda / (Nb + 1.0f)) * omegas[j];
            }
            break;
        }
        case BathPolicy::Closure: {  // from continuous spectrum
            break;
        }
        case BathPolicy::ReadFormula: {  // from continuous spectrum
            break;
        }
        case BathPolicy::ReadFile:  // #b850, #pbi, #rub
        default: {
            try {
                std::string bath_readfile = _Param->get<std::string>("bath_readfile", LOC(), "bath.spectrum");
                std::ifstream ifs(bath_readfile);

                std::string firstline, unit_str1, unit_str2, DIS_FLAG;

                // parse units of frequency & coefficients
                getline(ifs, firstline);
                std::stringstream sstr(firstline);
                sstr >> unit_str1 >> unit_str2;

                phys::uval uw = phys::us::parse(unit_str1);
                // if (uw.dim != phys::energy_d) LOG(FATAL) << "need dimension of energy";
                double w_unit = phys::us::conv(phys::au::unit, uw);

                phys::uval uc = phys::us::parse(unit_str2);
                // if (uc.dim != phys::energy_d) LOG(FATAL) << "need dimension of energy";
                double c_unit = phys::us::conv(phys::au::unit, uc);

                // read data lines
                double val;
                for (int j = 0; j < Nb; ++j) {
                    ifs >> DIS_FLAG;
                    if (DIS_FLAG == "WC") {
                        if (ifs >> val) omegas[j] = val / w_unit;              ///< omegac ~ [energy_d]
                        if (ifs >> val) coeffs[j] = val / pow(c_unit, 1.5e0);  ///< coeffs ~ [energy_d]**1.5
                    } else if (DIS_FLAG == "WS") {
                        if (ifs >> val) omegas[j] = val / w_unit;
                        if (ifs >> val) coeffs[j] = 2.0f * sqrt(0.5f * omegas[j] * omegas[j] * omegas[j] * val);
                    } else if (DIS_FLAG == "WG") {
                        if (ifs >> val) omegas[j] = val / w_unit;  ///< omegac ~ [energy_d]
                        if (ifs >> val) coeffs[j] = 2.0f * sqrt(0.5f * omegas[j] * omegas[j] * omegas[j]) * val;
                    }
                }
            } catch (std::runtime_error& e) {
                // LOG(FATAL) << "read spec.dat error";
            }
        }
    }
    mass    = DS->reg<double>("model.mass", N);
    freq    = DS->reg<double>("model.freq", N);
    x_mean  = DS->reg<double>("model.x_mean", N);
    p_mean  = DS->reg<double>("model.p_mean", N);
    x_sigma = DS->reg<double>("model.x_sigma", N);
    p_sigma = DS->reg<double>("model.p_sigma", N);
    for (int j = 0; j < N; ++j) {
        mass[j] = 1.0f;
        freq[j] = omegas[j % Nb];
        /* note:
            for finite temperature: Qoverbeta = 0.5*freq / dtanh(0.5*beta*freq)
            for zero temperature:   Qoverbeta = 0.5*freq
         */
        double Qoverbeta = 0.5f * freq[j] / (bath.beta > 0 ? std::tanh(0.5f * bath.beta * freq[j]) : 1.0f);
        x_sigma[j]       = std::sqrt(Qoverbeta / (mass[j] * freq[j] * freq[j]));
        p_sigma[j]       = std::sqrt(Qoverbeta * mass[j]);
    }


    /// 3) Coupling (saving order: L, nbath, Nb, FF)
    Q   = DS->reg<double>("model.Q", nbath * F * F);
    CL  = DS->reg<double>("model.CL", L * Nb);
    QL  = DS->reg<double>("model.QL", L * nbath * F * F);
    Xnj = DS->reg<double>("model.Xnj", N * F * F);
    switch (coupling_type) {
        case CouplingPolicy::SB: {
            //// CHECK_EQ(nbath, 1);
            //// CHECK_EQ(F, 2);
            Q[0] = 1.0f, Q[1] = 0.0f, Q[2] = 0.0f, Q[3] = -1.0f;
            break;
        }
        case CouplingPolicy::SE: {
            //// CHECK_LE(nbath, F);  // nbath should equal or less than F. (a ground state can be placed in last)
            for (int i = 0, idx = 0; i < nbath; ++i) {
                for (int j = 0; j < F; ++j) {
                    for (int k = 0; k < F; ++k, ++idx) Q[idx] = (i == j && i == k) ? 1.0f : 0.0f;
                }
            }
            break;
        }
        default: {
            std::string coupling_readfile = _Param->get<std::string>("coupling_readfile", LOC(), "coupling.dat");
            std::ifstream ifs(coupling_readfile);
            num_real tmp;
            for (int i = 0; i < nbath * F * F; ++i)
                if (ifs >> tmp) Q[i] = tmp;
            ifs.close();
        }
    }
    ARRAY_CLEAR(QL, L * nbath * FF);
    for (int ibath = 0, idx = 0; ibath < nbath; ++ibath) {
        for (int j = 0; j < Nb; ++j) {
            for (int i = 0, iL = 0; i < FF; ++i, ++idx) {
                double Qval = Q[ibath * FF + i];
                if (Qval != 0) {
                    QL[iL * nbath * FF + ibath * FF + i] = 1;                 // record there is a nonzero value
                    CL[iL * Nb + j]                      = coeffs[j] * Qval;  // reduce this value to CL
                    iL++;
                    // if (iL > L) LOG(FATAL);  // Q shoule be sparsed!
                }
                Xnj[idx] = coeffs[j] * Q[ibath * FF + i];  // merge coeffs into Q to obtain Xnj
            }
        }
    }

    // model field
    vpes = DS->reg<double>("model.vpes");
    grad = DS->reg<double>("model.grad", N);
    hess = DS->reg<double>("model.hess", N);
    V    = DS->reg<double>("model.V", FF);
    dV   = DS->reg<double>("model.dV", NFF);
    ddV  = DS->reg<double>("model.ddV", NNFF);

    // init & integrator
    x_init = DS->reg<double>("init.x", N);
    p_init = DS->reg<double>("init.p", N);
    x      = DS->reg<double>("integrator.x", N);
    p      = DS->reg<double>("integrator.p", N);
}

void Model_SystemBath::init_calc_impl(int stat) {
    Kernel_Random::rand_gaussian(x_init, N);
    Kernel_Random::rand_gaussian(p_init, N);
    for (int j = 0; j < N; ++j) {
        x_init[j] = x_mean[j] + x_init[j] * x_sigma[j];
        p_init[j] = p_mean[j] + p_init[j] * p_sigma[j];
    }
    // copy "init" field to "integrator"
    for (int j = 0; j < N; ++j) {
        x[j] = x_init[j];
        p[j] = p_init[j];
    }
}


int Model_SystemBath::exec_kernel_impl(int stat) {
    // calculate nuclear vpes and grad
    vpes[0] = 0.0f;
    for (int j = 0; j < N; ++j) {  // @profiling: self-time from 20% => 13%
        double wxj = freq[j] * x[j];
        vpes[0] += mass[j] * wxj * wxj;  // @note: don't add kenitic energy, that is not include in PIMD
        grad[j] = mass[j] * wxj;
    }
    vpes[0] *= 0.5;

    // calculate electronic V and dV
    for (int i = 0; i < FF; ++i) V[i] = Hsys[i];
    switch (coupling_type) {
        case CouplingPolicy::SB: {
            for (int j = 0; j < N; ++j) {
                V[0] += coeffs[j] * x[j];
                V[3] -= coeffs[j] * x[j];
            }
            break;
        }
        case CouplingPolicy::SE: {
            int Fadd1 = F + 1;
            for (int ibath = 0, idxV = 0, idxR = 0; ibath < nbath; ++ibath, idxV += Fadd1) {
                for (int j = 0; j < Nb; ++j, ++idxR) { V[idxV] += coeffs[j] * x[idxR++]; }
            }
            break;
        }
        default: {
            for (int ibath = 0, idxR = 0, idxQ0 = 0; ibath < nbath; ++ibath, idxQ0 += FF) {
                for (int j = 0; j < Nb; ++j, ++idxR) {
                    for (int i = 0, idxQ = idxQ0; i < FF; ++i, ++idxQ) { V[i] += Q[idxQ] * coeffs[j] * x[idxR]; }
                }
            }
            break;
        }
    }

    if (count_exec == 0) {  // only calculate once time
        ARRAY_CLEAR(dV, NFF);
        for (int ibath = 0, idxQ0 = 0, idxdV = 0; ibath < nbath; ++ibath, idxQ0 += FF) {
            for (int j = 0; j < Nb; ++j) {
                for (int i = 0, idxQ = idxQ0; i < FF; ++i, ++idxQ, ++idxdV) { dV[idxdV] = Q[idxQ] * coeffs[j]; }
            }
        }
    }

    // if (flag < 2) return 0;

    if (count_exec == 0) {
        ARRAY_CLEAR(hess, NN);
        ARRAY_CLEAR(ddV, NNFF);
        for (int j = 0, idx = 0, add = N + 1; j < N; ++j, idx += add) hess[idx] = mass[j] * freq[j] * freq[j];
        for (int i = 0; i < NNFF; ++i) ddV[i] = 0;
    }
    return 0;
}

};  // namespace PROJECT_NS
