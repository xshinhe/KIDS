#include "DataSet.h"

#include <cstring>
#include <memory>
#include <tuple>

#define ARRAY_SHOW(_A, _n1, _n2)                                                     \
    ({                                                                               \
        std::cout << "Show Array <" << #_A << ">\n";                                 \
        int _idxA = 0;                                                               \
        for (int _i = 0; _i < (_n1); ++_i) {                                         \
            for (int _j = 0; _j < (_n2); ++_j) std::cout << FMT(4) << (_A)[_idxA++]; \
            std::cout << std::endl;                                                  \
        }                                                                            \
    })

namespace PROJECT_NS {

class DataSetKeyParser {
   public:
    std::vector<std::string> terms;
    DataSetKeyParser(const std::string& key, const std::string& delimiter = ".") {
        size_t start = 0, end;
        while ((end = key.find(delimiter, start)) != std::string::npos) {
            terms.emplace_back(key, start, end - start);
            start = end + delimiter.length();
        }
        terms.emplace_back(key, start, key.size() - start);
    }
};

Shape::Shape(std::vector<std::size_t> dims) : _rank{dims.size()}, _dims{dims}, _ldims(dims.size(), 0), _size{1} {
    _ldims[_ldims.size() - 1] = 1;
    _size                     = dims[_dims.size() - 1];
    for (int i = _dims.size() - 2; i >= 0; --i) {
        _ldims[i] = _ldims[i + 1] * (_dims[i + 1]);
        _size *= _dims[i];
    }
}

Shape::Shape(std::size_t size) : _rank{1}, _dims{{size}}, _ldims{1}, _size{size} {};

template <class T>
Tensor<T>::Tensor(Shape S) : _shape{S} {
    _type = as_enum<T>();
    _size = _shape.size();
    _data = std::make_unique<T[]>(_size);
    memset(_data.get(), 0, _size * sizeof(T));
};

template <class T>
std::string Tensor<T>::repr() const {
    std::ostringstream os;
    T* ptr = _data.get();
    os << FMT(0) << as_str<T>();
    os << FMT(0) << _size;
    for (int i = 0; i < _size; ++i) os << FMT(8) << ptr[i];
    return os.str();
}

template <class T>
void Tensor<T>::dump(std::ostream& os) const {
    os << repr();
}

template <class T>
void Tensor<T>::load(std::istream& is) {
    for (int i = 0; i < _size; ++i) is >> _data[i];
}

template <class T>
void* Tensor<T>::data() {
    return _data.get();
}

DataSet::DataSet() {
    _size = 1;
    _type = kids_dataset_type;
    _data = std::make_unique<DataType>();
}


template <typename T>
T* DataSet::def(const std::string& key, Shape S) {
    DataSetKeyParser kp = DataSetKeyParser(key);

    DataSet* currentNode = this;
    for (size_t i = 0; i < kp.terms.size() - 1; ++i) {
        auto&& node = (*_data)[kp.terms[i]];
        if (!node) {
            (*_data)[kp.terms[i]] = std::make_unique<DataSet>();
            currentNode           = static_cast<DataSet*>((*_data)[kp.terms[i]].get());
        } else {
            currentNode = static_cast<DataSet*>(node.get());
        }
    }

    auto& leaf_node = (*_data)[kp.terms.back()];
    if (!leaf_node) leaf_node = std::make_unique<Tensor<T>>(S);

    if (leaf_node->type() != as_enum<T>()) throw std::runtime_error(std::string{key} + " : mismatched type!");
    if (leaf_node->size() != S.size()) throw std::runtime_error(std::string{key} + " : mismatched size!");

    return static_cast<T*>((static_cast<Tensor<T>*>(leaf_node.get())->_data).get());
}
template kids_bool* DataSet::def(const std::string& key, Shape S);
template kids_int* DataSet::def(const std::string& key, Shape S);
template kids_real* DataSet::def(const std::string& key, Shape S);
template kids_complex* DataSet::def(const std::string& key, Shape S);


template <typename T>
T* DataSet::def(const std::string& key, T* arr_in, Shape S) {
    T* arr = def<T>(key, S);
    for (int i = 0; i < S.size(); ++i) arr[i] = arr_in[i];

    // ARRAY_SHOW(arr_in, 1, S.size());
    // std::cout << node(key)->repr() << "\n";

    return arr;
}
template kids_bool* DataSet::def(const std::string& key, kids_bool* arr_in, Shape S);
template kids_int* DataSet::def(const std::string& key, kids_int* arr_in, Shape S);
template kids_real* DataSet::def(const std::string& key, kids_real* arr_in, Shape S);
template kids_complex* DataSet::def(const std::string& key, kids_complex* arr_in, Shape S);


template <typename T>
T* DataSet::def(const std::string& key, const std::string& key_in) {
    auto inode = node(key_in);
    if (inode->type() == kids_dataset_type) throw std::runtime_error(std::string{key_in} + " : failed copying dataset");
    return def<T>(key, (T*) inode->data(), inode->size());
}
template kids_bool* DataSet::def(const std::string& key, const std::string& key_in);
template kids_int* DataSet::def(const std::string& key, const std::string& key_in);
template kids_real* DataSet::def(const std::string& key, const std::string& key_in);
template kids_complex* DataSet::def(const std::string& key, const std::string& key_in);


template <typename T>
DataSet& DataSet::_def(const std::string& key, Shape S) {
    def<T>(key, S);
    return *this;
}
template DataSet& DataSet::_def<kids_bool>(const std::string& key, Shape S);
template DataSet& DataSet::_def<kids_int>(const std::string& key, Shape S);
template DataSet& DataSet::_def<kids_real>(const std::string& key, Shape S);
template DataSet& DataSet::_def<kids_complex>(const std::string& key, Shape S);


DataSet& DataSet::_undef(const std::string& key) {
    DataSetKeyParser kp = DataSetKeyParser(key);

    DataSet* currentNode = this;
    for (size_t i = 0; i < kp.terms.size() - 1; ++i) {
        auto& node = (*_data)[kp.terms[i]];
        if (!node) return *this;

        currentNode = static_cast<DataSet*>(node.get());
    }

    auto it = _data->find(kp.terms.back());
    if (it != _data->end()) { _data->erase(it); }
    return *this;
}

Node* DataSet::node(const std::string& key) {
    DataSetKeyParser kp = DataSetKeyParser(key);

    DataSet* currentNode = this;
    for (size_t i = 0; i < kp.terms.size() - 1; ++i) {
        auto& node = (*_data)[kp.terms[i]];
        if (!node) throw std::runtime_error(std::string{key} + " : access undefined key!");

        currentNode = static_cast<DataSet*>(node.get());
    }

    auto& leaf_node = (*_data)[kp.terms.back()];
    if (!leaf_node) throw std::runtime_error(std::string{key} + " : access undefined key!");
    return leaf_node.get();
}

template <typename T = DataSet>
T* DataSet::at(const std::string& key) {
    auto leaf_node = node(key);
    if (leaf_node->type() != as_enum<T>()) throw std::runtime_error(std::string{key} + " : bad conversion!");
    if (leaf_node->type() == kids_dataset_type) return (T*) (static_cast<DataSet*>(leaf_node));
    return static_cast<T*>((static_cast<Tensor<T>*>(leaf_node)->_data).get());
}
template kids_bool* DataSet::at(const std::string& key);
template kids_int* DataSet::at(const std::string& key);
template kids_real* DataSet::at(const std::string& key);
template kids_complex* DataSet::at(const std::string& key);
template kids_dataset* DataSet::at(const std::string& key);


std::string DataSet::repr() const {
    std::ostringstream os;
    std::vector<std::tuple<std::string, Node*>> stack;

    stack.push_back(std::make_tuple("", (Node*) this));

    while (!stack.empty()) {
        auto [parent, currentNode] = stack.back();
        stack.pop_back();

        DataType* d_ptr = ((DataSet*) (currentNode))->_data.get();

        for (auto& i : (*d_ptr)) {
            std::string key = (parent == "") ? i.first : parent + "." + i.first;
            Node* inode     = i.second.get();
            if (inode->type() == kids_dataset_type) {
                stack.push_back(std::make_tuple(key, inode));
            } else {
                os << key << inode->repr() << "\n";
            }
        }
    }
    return os.str();
}

void DataSet::dump(std::ostream& os) const { os << repr(); }

void DataSet::load(std::istream& is) {
    std::string key, typeflag;
    int size;
    while (is >> key >> typeflag >> size) {
        if (typeflag == as_str<kids_int>()) {
            kids_int* ptr = def<kids_int>(key, size);
            for (int i = 0; i < size; ++i) is >> ptr[i];
        } else if (typeflag == as_str<kids_real>()) {
            kids_real* ptr = def<kids_real>(key, size);
            for (int i = 0; i < size; ++i) is >> ptr[i];
        } else if (typeflag == as_str<kids_complex>()) {
            kids_complex* ptr = def<kids_complex>(key, size);
            for (int i = 0; i < size; ++i) is >> ptr[i];
        }
    }
}

void* DataSet::data() { return _data.get(); }

};  // namespace PROJECT_NS
