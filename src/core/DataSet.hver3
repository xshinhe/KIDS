/**@file        DataSet.h
 * @brief       this file provide DataSet class
 * @details     DataSet class is a minimal dynamic container. This file includes
 *              Node class as interface,
 *              Shape class control the shape of the tensor
 *              Tensor class inherited from Node
 *              DataSet class with a tree structure for storage of Tensor
 *
 * @author      [author] [author2] [author3]
 * @date        [latest-date]
 * @version     [version]
 * @copyright   [copyright]
 **********************************************************************************
 * @par revision [logs]:
 * <table>
 * <tr><th> Date    <th> Version    <th> Author    <th> Description
 * <tr><td>[date]   <td>[version]   <td>[author]   <td> [commit]
 * </table>
 *
 **********************************************************************************
 */

#ifndef DataSet_H
#define DataSet_H

#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "types.h"

namespace PROJECT_NS {

/**
 * control the output printing format
 */
constexpr inline int FMT_WIDTH(int X) { return X + 7; }
#define FMT(X)                                                            \
    " " << std::setiosflags(std::ios::scientific) /*scientific notation*/ \
        << std::setprecision(X)                   /*precision*/           \
        << std::right                             /*alignment*/           \
        << std::setw(FMT_WIDTH(X))                /*width of text*/


/**********************************************************************************
    This file includes classes:
    1) Node
    2) Shape
    3) Tensor<T>
    4) DataSet
**********************************************************************************/

/**
 * Node class is an abstract interface. A Node will store a tensor or another Node
 */
class Node {
   public:
    virtual ~Node() = default;

    ///< get the type of the Node
    inline kids_dtype type() const { return _type; }

    ///< get the size of the Node
    inline std::size_t size() const { return _size; }

    ///< get representation of the Node (pure virtual)
    virtual std::string repr() const = 0;

    ///< dump Node to an io stream (pure virtual)
    virtual void dump(std::ostream& os) const = 0;

    ///< load Node from an io stream (pure virtual)
    virtual void load(std::istream& is) = 0;

    ///< fetch data pointer in Node (pure virual)
    virtual void* data() = 0;

   protected:
    kids_dtype _type  = kids_void_type;  ///< data type of the Node
    std::size_t _size = 0;               ///< size of storage
};

/**
 * Shape class provide information about of a Tensor's shape
 */
class Shape {
   public:
    ///< construct from a vector
    Shape(std::vector<std::size_t> dims);

    ///< construct from a number (rank-1 Shape)
    Shape(std::size_t size);

    /**
     * Delete new operators to prevent dynamic memory allocation
     */
    void* operator new(size_t)   = delete;
    void* operator new[](size_t) = delete;

    ///< get rank of a Shape
    inline int rank() const { return _rank; }

    ///< get data size described by a Shape
    inline int size() const { return _size; }

   private:
    std::size_t _rank;                ///< rank of the shape
    std::vector<std::size_t> _dims;   ///< dimensions for each rank
    std::vector<std::size_t> _ldims;  ///< leading dimensions
    std::size_t _size;                ///< size of data
};

/**
 * Tensor class is the container for array-like data
 */
template <typename T>
class Tensor final : public Node {
   public:
    ///< construct from a Shape
    Tensor(Shape S);

    ///< get representation of the Tensor
    virtual std::string repr() const override;

    ///< dump Tensor to an io stream
    virtual void dump(std::ostream& os) const override;

    ///< load Tensor to an io stream
    virtual void load(std::istream& is) override;

    ///< fetch data pointer in Tensor
    virtual void* data();

   private:
    friend class DataSet;

    std::unique_ptr<T[]> _data;
    Shape _shape;
};

/**
 * DataSet class is a tree-structured container for storage of Tensor and
 * other DataSet.
 */
class DataSet final : public Node {
   public:
    using NodePtr  = std::unique_ptr<Node>;
    using DataType = std::map<std::string, NodePtr>;

    DataSet();

    ///< define a Tensor in DataSet by key (if defined, it fetches the data)
    template <typename T>
    T* def(const std::string& key, Shape S = 1);

    ///< define a Tensor in DataSet by key and initialize its value
    template <typename T>
    T* def(const std::string& key, T* arr_in, Shape S = 1);

    ///< copy T tensor in DataSet from a key to another
    template <typename T>
    T* def(const std::string& key, const std::string& key_in);

    ///< define a Tensor in DataSet by key, but return self reference
    template <typename T>
    DataSet& _def(const std::string& key, Shape S = 1);

    ///< undef a Tensor by key
    DataSet& _undef(const std::string& key);

    ///< fetch the Node pointer by key
    Node* node(const std::string& key);

    ///< fetch the data by key
    template <typename T = DataSet>
    T* at(const std::string& key);

    ///< get representation of the DataSet
    virtual std::string repr() const override;

    ///< dump DataSet to an io stream
    virtual void dump(std::ostream& os) const override;

    ///< load DataSet from an io stream
    virtual void load(std::istream& is) override;

    ///< fetch data pointer in DataSet @deprecated
    virtual void* data();

   private:
    std::unique_ptr<DataType> _data;
};

};  // namespace PROJECT_NS

#endif  // DataSet_H
