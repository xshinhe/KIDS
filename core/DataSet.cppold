#include "DataSet.h"

namespace kids {

namespace details {  // hidden scope


Tree::~Tree() {
    if (ownership) _delete();
}

template <typename T>
Tree& Tree::def(const std::string& key, std::size_t size) {
    KeyHelper kh    = KeyHelper(key);
    DataType* d_ptr = static_cast<DataType*>(_data);
    if (kh.is_leaf) {  // leaf node
        if (d_ptr->find(key) != d_ptr->end()) throw state_conflicted_key_error(key);
        (*d_ptr)[key] = new Node<T>(size);
    } else {  // non-leaf node
        if (d_ptr->find(kh.key1) == d_ptr->end()) (*d_ptr)[kh.key1] = new Tree;
        if ((*d_ptr)[kh.key1]->type() != NodeType::Tree) throw state_conflicted_key_error(kh.key1);
        ((Tree*) (*d_ptr)[kh.key1])->def<T>(kh.key2, size);
    }
    return *this;
}

/**
 * @brief      undefine leaf/non-leaf node(s) in a tree
 *
 * @param[in]  key   The key
 *
 * @return     Tree reference after undefintion
 */
Tree& Tree::undef(const std::string& key) {
    KeyHelper kh    = KeyHelper(key, false);
    Tree* psubtree  = kh.is_leaf ? this : &subref(kh.key1);
    DataType* d_ptr = static_cast<DataType*>(psubtree->_data);
    if (d_ptr->find(kh.key2) == d_ptr->end()) throw state_undefined_key_error(kh.key2);
    delete (*d_ptr)[kh.key2];
    d_ptr->erase(kh.key2);
    return *this;
}


/**
 * @brief      get a sub-tree of a tree
 *
 * @param[in]  key   The key of a subtree
 *
 * @return     Tree reference
 */
Tree& Tree::subref(const std::string& key) {  // @bugs it will destroy the alias structure
    KeyHelper kh    = KeyHelper(key);
    DataType* d_ptr = static_cast<DataType*>(_data);
    if (kh.is_leaf) {
        if (d_ptr->find(key) == d_ptr->end()) throw state_undefined_key_error(key);
        if (NodeType::Tree != (*d_ptr)[key]->type()) throw state_mismatched_type_error(key);
        return *((Tree*) (*d_ptr)[key]);
    }
    if (d_ptr->find(kh.key1) == d_ptr->end()) throw state_undefined_key_error(kh.key1);
    return ((Tree*) (*d_ptr)[kh.key1])->subref(kh.key2);
};

/**
 * @brief get information (type & size & storage) of a key in the tree
 */
NodeGeneric::InfoType Tree::info(const std::string& key) noexcept {
    KeyHelper kh    = KeyHelper(key);
    DataType* d_ptr = static_cast<DataType*>(_data);
    if (kh.is_leaf && d_ptr->find(key) != d_ptr->end()) {
        NodeGeneric* inode = (*d_ptr)[key];
        return inode->info();
    } else if (!kh.is_leaf && d_ptr->find(kh.key1) != d_ptr->end()) {
        return ((Tree*) (*d_ptr)[kh.key1])->info(kh.key2);
    }
    return std::make_tuple(NodeGeneric::NodeType::Void, 0, nullptr, nullptr);
};

/**
 * @brief ask if the key exists in the tree structure
 */
bool Tree::has_key(const std::string& key) { return (std::get<3>(info(key)) != nullptr); }

/**
 * @brief register an array and return its pointer

 * @param key : the address of the array, adjointed by dot delimiter
 * @param size_array : the size of the array
 * @tparam T : the type of the data
 * @return T* pointer.
 *     1) If the key of array has been existed, it will only return the
 *     pointer of the array;
 *     2) otherwise, it will define a new array assoicated with the key,
 *     and further return its pointer.
 */
template <typename T>
T* Tree::reg(const std::string& key, std::size_t size_array, bool required) {
    if (!has_key(key)) def<T>(key, size_array);
    auto&& res = info(key);
    if (std::get<0>(NodeGeneric::TypeHelper<T>()) != std::get<0>(res)) throw state_mismatched_type_error(key);
    if (size_array > 0 && size_array != std::get<1>(res)) throw state_mismatched_size_error(key);
    return (T*) std::get<2>(res);
};

Tree::KeyNodeList Tree::flatten(bool indeep, const std::string& parent) {
    KeyNodeList list;
    DataType* d_ptr = static_cast<DataType*>(_data);
    for (auto& i : (*d_ptr)) {
        std::string key    = (parent == "") ? i.first : utils::concat(parent, ".", i.first);
        NodeGeneric* inode = i.second;
        if (inode->type() == NodeGeneric::NodeType::Tree) {
            auto&& list2 = ((Tree*) inode)->flatten(indeep, key);
            list.insert(list.end(), std::make_move_iterator(list2.begin()), std::make_move_iterator(list2.end()));
        } else {
            list.push_back(std::make_tuple(key, inode));
        }
    }
    return list;
}

std::string Tree::repr(NodeGeneric::Format format, const std::string& lead) {
    std::ostringstream os;
    DataType* d_ptr = static_cast<DataType*>(_data);
    switch (format) {
        case NodeGeneric::Format::Free: {
            for (auto& i : flatten()) { os << std::get<0>(i) << std::get<1>(i)->repr(format, lead) << "\n"; }
            break;
        }
        case NodeGeneric::Format::Json: {
            os << lead << "{\n";
            std::string nextlead = lead + "  ";
            for (auto& i : (*d_ptr)) {
                NodeGeneric* inode = i.second;
                os << nextlead << "\"" << i.first << "\" : ";
                os << nextlead << inode->repr(format, nextlead);
                os << ",\n";
            }
            os << lead << "}";
            break;
        }
    }
    return os.str();
}

/**
 * @brief dump Tree information to a filestream or a file
 */
void Tree::dump(std::ostream& os, NodeGeneric::Format format) { os << repr(format); }

void Tree::dump(const std::string& file, NodeGeneric::Format format) {
    std::ofstream ofs(file);
    dump(ofs, format);
    ofs.close();
}

/**
 * @brief load Tree information from a filestream or a file
 */
void Tree::load(std::istream& is, NodeGeneric::Format format) {
    switch (format) {
        case NodeGeneric::Format::Free: {  // as an easily implemented format
            std::string key, typeflag;
            int size;
            while (is >> key >> typeflag >> size) {
                if (typeflag == "Int") {
                    int* ptr = reg<int>(key, size);
                    for (int i = 0; i < size; ++i) is >> ptr[i];
                } else if (typeflag == "Real") {
                    kids_real* ptr = reg<kids_real>(key, size);
                    for (int i = 0; i < size; ++i) is >> ptr[i];
                } else if (typeflag == "Complex") {
                    kids_complex* ptr = reg<kids_complex>(key, size);
                    for (int i = 0; i < size; ++i) is >> ptr[i];
                }
            }
            break;
        }
        case NodeGeneric::Format::Json: {
            throw basic_error("Not implemented");
            break;
        }
    }
}

void Tree::load(const std::string& file, NodeGeneric::Format format) {
    std::ifstream ifs(file);
    load(ifs, format);
    ifs.close();
}


/**
 * @brief implemention of deconstructor
 */
void Tree::_delete() {
    DataType* d_ptr = static_cast<DataType*>(_data);
    for (auto& i : (*d_ptr)) delete i.second;
    delete d_ptr;  // essential!
}


};  // namespace details

};  // namespace kids
