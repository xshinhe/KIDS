#include "Kernel_Elec_MMQ.h"

#include "../core/linalg.h"
#include "Kernel_Declare.h"
#include "Kernel_Random.h"
#include "Kernel_Representation.h"

#define ARRAY_SHOW(_A, _n1, _n2)                                                     \
    ({                                                                               \
        std::cout << "Show Array <" << #_A << ">\n";                                 \
        int _idxA = 0;                                                               \
        for (int _i = 0; _i < (_n1); ++_i) {                                         \
            for (int _j = 0; _j < (_n2); ++_j) std::cout << FMT(4) << (_A)[_idxA++]; \
            std::cout << std::endl;                                                  \
        }                                                                            \
    })

namespace PROJECT_NS {

void Kernel_Elec_MMQ::read_param_impl(Param* PM) {
    mmq_type = MMQPolicy::_from(PM->get<std::string>("mmq_flag", LOC(), "MMF"));
    scale    = PM->get<num_real>("scale", LOC(), 1.0);
    Fref     = PM->get<int>("Fref", LOC(), Dimension::F);

    gamma      = PM->get<num_real>("gamma", LOC(), Kernel_Elec_CMM::gamma_wigner(Dimension::F));
    pure_phase = PM->get<bool>("pure_phase", LOC(), true);
    cont_phase = PM->get<bool>("cont_phase", LOC(), true);
    rand_act   = PM->get<bool>("rand_act", LOC(), false);
}

void Kernel_Elec_MMQ::init_calc_impl(int stat) {
    for (int iP = 0; iP < Dimension::P; ++iP) {
        num_complex* w        = Kernel_Elec::w + iP;
        num_complex* c        = Kernel_Elec::c + iP * Dimension::F;
        num_complex* rho_ele  = Kernel_Elec::rho_ele + iP * Dimension::FF;
        num_complex* rho_dual = Kernel_Elec::rho_dual + iP * Dimension::FF;
        num_complex* rho_nuc  = Kernel_Elec::rho_nuc + iP * Dimension::FF;
        num_complex* U        = Kernel_Elec::U + iP * Dimension::FF;
        int* occ_nuc          = Kernel_Elec::occ_nuc + iP;

        /////////////////////////////////////////////////////////////////

        w[0]     = (rand_act) ? num_complex(Dimension::F) : 1.0e0;  ///< initial measure
        *occ_nuc = Kernel_Elec::occ0;                               ///< initial occupation
        /// < initial c (not used)
        for (int i = 0; i < Dimension::F; ++i) {
            double randu;
            Kernel_Random::rand_uniform(&randu, 1, phys::math::twopi);
            c[i] = (i == *occ_nuc ? sqrt(1 + gamma) : sqrt(gamma)) * exp(phys::math::im * randu) / sqrt(xi);
        }
        Kernel_Elec::ker_from_c(rho_ele, c, xi, gamma, Dimension::F);
        for (int i = 0, ik = 0; i < Dimension::F; ++i) {
            for (int k = 0; k < Dimension::F; ++k, ++ik) {
                rho_dual[ik] = ((i == *occ_nuc && k == *occ_nuc) ? 2.0e0 : 0.0e0) - rho_ele[ik];
            }
        }
        rho_nuc;                     ///< initial rho_nuc (not used)
        ARRAY_EYE(U, Dimension::F);  ///< initial propagator
    }
    Kernel_Elec::c_init        = _DataSet->set("init.c", Kernel_Elec::c, Dimension::PF);
    Kernel_Elec::rho_ele_init  = _DataSet->set("init.rho_ele", Kernel_Elec::rho_ele, Dimension::PFF);
    Kernel_Elec::rho_dual_init = _DataSet->set("init.rho_dual", Kernel_Elec::rho_dual, Dimension::PFF);
    // Kernel_Elec::rho_nuc_init = _DataSet->set("init.rho_nuc", Kernel_Elec::rho_nuc, Dimension::PFF);
    Kernel_Elec::T_init = _DataSet->set("init.T", Kernel_Elec::T, Dimension::PFF);
    exec_kernel(stat);
}

int Kernel_Elec_MMQ::exec_kernel_impl(int stat) {
    for (int iP = 0; iP < Dimension::P; ++iP) {
        num_complex* U             = Kernel_Elec::U + iP * Dimension::FF;
        num_complex* c             = Kernel_Elec::c + iP * Dimension::F;
        num_complex* c_init        = Kernel_Elec::c_init + iP * Dimension::F;
        num_complex* rho_ele       = Kernel_Elec::rho_ele + iP * Dimension::FF;
        num_complex* rho_ele_init  = Kernel_Elec::rho_ele_init + iP * Dimension::FF;
        num_complex* rho_dual      = Kernel_Elec::rho_dual + iP * Dimension::FF;
        num_complex* rho_dual_init = Kernel_Elec::rho_dual_init + iP * Dimension::FF;
        num_complex* rho_nuc       = Kernel_Elec::rho_nuc + iP * Dimension::FF;
        num_complex* K1            = Kernel_Elec::K1 + iP * Dimension::FF;
        num_complex* K2            = Kernel_Elec::K2 + iP * Dimension::FF;

        num_real* T      = Kernel_Elec::T + iP * Dimension::FF;
        num_real* T_init = Kernel_Elec::T_init + iP * Dimension::FF;

        /////////////////////////////////////////////////////////////////

        for (int ik = 0; ik < Dimension::FF; ++ik) rho_ele[ik] = rho_ele_init[ik];
        for (int ik = 0; ik < Dimension::FF; ++ik) rho_dual[ik] = rho_dual_init[ik];

        // 1) transform from inp_repr => ele_repr
        Kernel_Representation::transform(rho_ele, T_init, Dimension::F,         //
                                         Kernel_Representation::inp_repr_type,  //
                                         Kernel_Representation::ele_repr_type,  //
                                         SpacePolicy::L);
        Kernel_Representation::transform(rho_dual, T_init, Dimension::F,        //
                                         Kernel_Representation::inp_repr_type,  //
                                         Kernel_Representation::ele_repr_type,  //
                                         SpacePolicy::L);

        // 2) propagte along ele_repr
        ARRAY_MATMUL3_TRANS2(rho_ele, U, rho_ele, U, Dimension::F, Dimension::F, Dimension::F, Dimension::F);
        ARRAY_MATMUL3_TRANS2(rho_dual, U, rho_dual, U, Dimension::F, Dimension::F, Dimension::F, Dimension::F);

        // 3) transform back from ele_repr => inp_repr
        Kernel_Representation::transform(rho_ele, T, Dimension::F,              //
                                         Kernel_Representation::ele_repr_type,  //
                                         Kernel_Representation::inp_repr_type,  //
                                         SpacePolicy::L);
        Kernel_Representation::transform(rho_dual, T, Dimension::F,             //
                                         Kernel_Representation::ele_repr_type,  //
                                         Kernel_Representation::inp_repr_type,  //
                                         SpacePolicy::L);

        int max1 = Kernel_Elec_SH::max_choose(rho_ele);
        int max2 = Kernel_Elec_SH::max_choose(rho_dual);

        if (max1 == max2) {
            occ_nuc[0]                     = max1;
            Kernel_NADForce::NADForce_type = NADForcePolicy::BO;
            Kernel_Elec::ker_from_rho(K1, rho_ele, 1, 0, Dimension::F, true, max1);
            K1[max1 * Dimension::Fadd1] = rho_ele[max1 * Dimension::Fadd1];
        } else {
            Kernel_NADForce::NADForce_type = NADForcePolicy::EHR;
            for (int ik = 0; ik < Dimension::FF; ++ik) rho_nuc[ik] = rho_ele[ik];
            Kernel_Elec::ker_from_rho(K1, rho_ele, 1, 0, Dimension::F);
            Kernel_Elec::ker_from_rho(K2, rho_dual, 1, 0, Dimension::F);
        }
    }
    return 0;
}

};  // namespace PROJECT_NS
